<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>구구단</title>
    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.development.js"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
    ></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
      class GuGuDan extends React.Component {
        constructor(props) {
          //20~23의 this 까지 지우고 state만 남기고 써도 됨.
          super(props);
          this.state = {
            //바뀌는 것들을 속성으로 추가
            first: Math.ceil(Math.random() * 9), //1~9 사이 값들을 랜덤으로 추출
            second: Math.ceil(Math.random() * 9),
            value: "",
            result: "",
          };
        }
        //매소드. 이렇게 class 안에 매소드로 따로 분리한 경우에는 function(e){} 이렇게 쓰면 안 됨.
        //this 자체가 달라져버리기 때문. 화살표 함수로 쓸 것.
        onSubmit = (e) => {
          e.preventDefault();
          if (
            parseInt(this.state.value) ===
            this.state.first * this.state.second
          ) {
            this.setState({
              result: this.state.value + " 정답",
              //함수형 setState를 쓰는 때: setState 안에 this.state를 사용하는 경우,
              //즉 직전 값이 새로운 값을 만드는 데 사용되는 경우.
              //이런 경우에는 아래와 같이 함수 안에 써주는 것이 안 헷갈리고 좋다고 함.
              //또한 이런 내용을 render 부분에 직접 써주면, 렌더가 될 때마다 함수를 새로 생성하게 되는데
              //이는 성능을 불필요하게 저하시키게 되므로 역시 분리할 필요 있음.
              /* 
                this.setState((prevState) => {
                    return {
                        result: prevState.value + " 정답",
                        first: Math.ceil(Math.random() * 9),
                        second: Math.ceil(Math.random() * 9),
                        value: "",
                    };
                });
              */
              first: Math.ceil(Math.random() * 9),
              second: Math.ceil(Math.random() * 9),
              value: "",
            });
            this.input.focus();
          } else {
            this.setState({
              result: "땡",
              value: "",
            });
            this.input.focus();
          }
        };
        onChange = (e) => {
          this.setState({ value: e.target.value });
        };
        onSomething = (something) => {
          this.input = something;
        };

        input;

        render() {
          return (
            //div 상위요소로 모든 요소들을 한번에 묶어주어야 하는데, 이걸 제거하고 싶은 경우 가짜 태그를 사용.
            //<></> 이게 안 되는 경우 babel이 지원을 안 하는 것이므로
            //<React.Fragment>로 감싸주면 화면 상에서 쓸데없는 div 생성 안됨.
            <React.Fragment>
              <div>
                {this.state.first} X {this.state.second} ?
              </div>

              <form
                onSubmit={this.onSubmit}
                /* 폼이 제출되었을 때, input의 입력값에 따라 정답인 경우와 오답인
                경우 화면을 어떻게 출력할 것인지 state를 set 해줌. 
                하지만 웬만하면 JSX와 script를 섞어 쓰지 않는 것이 좋으므로 분리하여
                class의 매소드에 적어줌. */
              >
                <input
                  //만약 javascript에서처럼 DOM에 직접 접근하고 싶을 때는
                  //class에 정의해둔 ref를 이용해서 조작하는 것이 좋음.
                  //ref 안에는 아무 함수나 적어도 되고, 사용된 것들은 그냥 class 내부에 선언만 해줘도 됨.
                  ref={this.onSomething}
                  type="number"
                  value={this.state.value}
                  //그냥 여기까지만 쓰면 input 변화X. state를 함부로 바꿀 수 없기 때문에 변화하는 상태마다 일일이 지정을 해주어야 함.
                  //즉 위의 class의 state에는 이런 방식으로 수동 제어해줄 항목들만 넣어야 한다는 것.
                  onChange={
                    this.onChange
                    //사용자가 값 입력 시(onChange) 입력한 값을 화면에 출력하도록 state를 바꿔줌.
                    //state 부분이 화면 출력 관련 부분이므로.
                  }
                />
                <button>입력</button>
              </form>
              <div>{this.state.result}</div>
            </React.Fragment>
          );
        }
      }
    </script>
    <script type="text/babel">
      ReactDOM.render(
        //this.setState 내부에 지정된 요소들에 변화가 있을 때마다 렌더가 되는데, 이는 성능 최적화에 중요한 요소.
        //계속 렌더할 필요가 없는 요소들은 빼고 정말 필요한 것들을 둬야 렌더 시간이 지나치게 오래 소요되지 않음.

        //동일 컴포넌트를 여러 개 넣을 수도 있음. 각각은 개별적으로 동작. 물론 부모 요소 아래에 묶어 넣어야 함.
        /* <div><GuGuDan /><GuGuDan /><GuGuDan /></div>, */
        <GuGuDan />,
        document.querySelector("#root")
      );
    </script>
  </body>
</html>
